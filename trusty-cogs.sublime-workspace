{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"get_cl",
				"get_cleverbotio_response"
			],
			[
				"get_cleve",
				"get_cleverbotcom_response"
			],
			[
				"div",
				"div_emoji"
			],
			[
				"check_",
				"check_account_added"
			],
			[
				"oaut",
				"oauth_check"
			],
			[
				"oau",
				"oauth_check"
			],
			[
				"twit",
				"twitch_id"
			],
			[
				"twitc",
				"twitch_name"
			],
			[
				"prof",
				"profile_image_url"
			],
			[
				"def",
				"default_json"
			],
			[
				"permiss",
				"permissions_for"
			],
			[
				"msg",
				"msg_send"
			],
			[
				"added",
				"added_accounts"
			],
			[
				"firema",
				"firemaking_rank"
			],
			[
				"ranged_",
				"ranged_level"
			],
			[
				"constitut",
				"constitution"
			],
			[
				"strength",
				"strength_xp"
			],
			[
				"defence",
				"defence_rank"
			],
			[
				"ma",
				"make_url_player_details_ajax"
			],
			[
				"last_c",
				"last_checked_time"
			],
			[
				"last",
				"last_modified"
			],
			[
				"make",
				"make_url_player_details"
			],
			[
				"runesca",
				"runescape_name"
			],
			[
				"get_prof",
				"get_profile_obj"
			],
			[
				"range",
				"ranged_total"
			],
			[
				"mele",
				"melee_total"
			],
			[
				"magic",
				"magic_total"
			],
			[
				"scissors",
				"scissors"
			],
			[
				"acti",
				"activitycheck"
			],
			[
				"settings",
				"settings_file"
			],
			[
				"server",
				"server_roles"
			],
			[
				"check",
				"check_gab_usernames"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "Remote:   origin @ https://github.com/TrustyJAID/Trusty-cogs.git\nLocal:    V3 E:\\github\\Trusty-cogs\nHead:     81fa336 [Twitch] Follow PEP 8\n\n\nUntracked files:\n\tblizzard/\n\tconvertinfo.py\n\thockey/pickems.py\n\nChanges:\n\tModified   hockey/game.py\n\tModified   hockey/hockey.py\n\tModified   trusty-cogs.sublime-workspace\n\n\n# Movement:\n#    r = refresh status\n#    1-5 = jump to section\n#    n = next item, N = next section\n#    p = previous item, P = previous section\n#\n# Staging:\n#    s = stage file/section, S = stage all unstaged files\n#    ctrl+shift+s = stage all unstaged and untracked files\n#    u = unstage file/section, U = unstage all files\n#    backspace = discard file/section, shift+backspace = discard everything\n#\n# Commit:\n#    c = commit, C = commit -a (add unstaged)\n#    ctrl+shift+c = commit --amend (amend previous commit)\n#\n# Other:\n#    i = ignore file, I = ignore pattern\n#    enter = open file\n#    d = view diff\n#\n# Stashes:\n#    a = apply stash, A = pop stash\n#    z = create stash, Z = create stash including untracked files\n#    backspace = discard stash",
			"settings":
			{
				"buffer_size": 1075,
				"line_ending": "Windows",
				"name": "*git-status*: Trusty-cogs",
				"read_only": true,
				"scratch": true
			}
		},
		{
			"file": "twitch/twitch.py",
			"settings":
			{
				"buffer_size": 18823,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "import discord\nimport aiohttp\nimport asyncio\nimport json\nfrom datetime import datetime\nfrom io import BytesIO\nfrom redbot.core import commands, checks, Config\nfrom .teams import teams\nfrom .teamentry import TeamEntry\nfrom .menu import hockey_menu\nfrom .embeds import *\nfrom .helper import *\nfrom .game import Game\nfrom .pickems import Pickems\nfrom.standings import Standings\n\n\ntry:\n    from .oilers import Oilers\nexcept ImportError:\n    pass\n\n__version__ = \"2.1.5\"\n__author__ = \"TrustyJAID\"\n\nclass Hockey(commands.Cog):\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.session = aiohttp.ClientSession(loop=self.bot.loop)\n        default_global = {\"teams\":[], \"created_gdc\":False}\n        for team in teams:\n            team_entry = TeamEntry(\"Null\", team, 0, [], {}, [], \"\")\n            default_global[\"teams\"].append(team_entry.to_json())\n        team_entry = TeamEntry(\"Null\", \"all\", 0, [], {}, [], \"\")\n        default_global[\"teams\"].append(team_entry.to_json())\n        default_guild = {\"standings_channel\":None, \"standings_type\":None, \"post_standings\":False, \"standings_msg\":None,\n                         \"create_channels\":False, \"category\":None, \"gdc_team\":None, \"gdc\":[], \"delete_gdc\":True,\n                         \"rules\":\"\", \"team_rules\":\"\", \"pickems\": []}\n        default_channel = {\"team\":[], \"to_delete\":False}\n\n        self.config = Config.get_conf(self, 13457745779)\n        self.config.register_global(**default_global, force_registration=True)\n        self.url = \"https://statsapi.web.nhl.com\"\n        self.teams = teams\n        self.headshots = \"https://nhl.bamcontent.com/images/headshots/current/168x168/{}.jpg\"\n        self.loop = bot.loop.create_task(self.get_team_goals())\n\n    ##############################################################################\n    # Here is all the logic for gathering game data and updating information\n\n    async def get_day_games(self):\n        \"\"\"\n            Gets all current games for the day as a list of game objects\n        \"\"\"\n        async with self.session.get(self.url + \"/api/v1/schedule\") as resp:\n            data = await resp.json()\n        game_list = []\n        for link in data[\"dates\"][0][\"games\"]:\n            try:\n                async with self.session.get(self.url + link[\"link\"]) as resp:\n                    data = await resp.json()\n                game_list.append(await Game.from_json(data))\n            except Exception as e:\n                print(\"error here {}\".format(e))\n                continue\n        return game_list\n\n    @commands.command() \n    @checks.is_owner()\n    async def getgoals(self, ctx):  \n        \"\"\"Loop to check what teams are playing and see if a goal was scored\"\"\" \n        to_remove = []  \n        games_playing = True    \n        # print(link)   \n        with open(\"/mnt/e/github/Trusty-cogs/hockeytest/testgame.json\", \"r\") as infile: \n            data = json.loads(infile.read())    \n        # print(data)   \n        game_data = await Game.from_json(data)  \n        await self.check_game_state(game_data)                  \n        if (game_data.home_score + game_data.away_score) != 0:  \n            await self.check_team_goals(game_data)\n\n    async def refactor_data(self):\n        chan_list = await self.config.all_channels()\n        for channel_id in chan_list:\n            channel = self.bot.get_channel(id=channel_id)\n            if channel is None:\n                continue\n            teams = await self.config.channel(channel).team()\n            if type(teams) is not list:\n                await self.config.channel(channel).team.set([teams])\n\n    async def get_team_goals(self):\n        \"\"\"\n            This loop grabs the current games for the day then passes off to other functions as necessary\n        \"\"\"\n        await self.bot.wait_until_ready()\n        while self is self.bot.get_cog(\"Hockey\"):\n            await self.refactor_data()\n            async with self.session.get(self.url + \"/api/v1/schedule\") as resp:\n                data = await resp.json()\n\n            games = [game[\"link\"] for game in data[\"dates\"][0][\"games\"] if game[\"status\"][\"abstractGameState\"] != \"Final\"]\n            games_playing = False\n            while games != []:\n                to_remove = []\n                games_playing = True\n                for link in games:\n                    try:\n                        async with self.session.get(self.url + link) as resp:\n                            data = await resp.json()\n                    except Exception as e:\n                        print(e)\n                        continue\n                    game_data = await Game.from_json(data)\n                    await self.check_game_state(game_data)\n\n                    print(\"{} @ {}\".format(game_data.away_team, game_data.home_team))\n\n                    if game_data.game_state == \"Final\":\n                        all_teams = await self.config.teams()\n                        home = await self.get_team(game_data.home_team)\n                        away = await self.get_team(game_data.away_team)\n                        all_teams.remove(home)\n                        all_teams.remove(away)\n                        home[\"goal_id\"] = {}\n                        away[\"goal_id\"] = {}\n                        all_teams.append(home)\n                        all_teams.append(away)\n                        await self.config.teams.set(all_teams)\n                        to_remove.append(link)\n\n                for link in to_remove:\n                    try:\n                        games.remove(link)\n                    except:\n                        pass\n                await asyncio.sleep(60)\n            print(\"Games Done Playing\")\n            if games_playing:\n                await self.config.created_gdc.set(False)\n            all_teams = await self.config.teams()\n            for team in await self.config.teams():\n                all_teams.remove(team)\n                team[\"goal_id\"] = {}\n                team[\"game_state\"] = \"Null\"\n                team[\"game_start\"] = \"\"\n                team[\"period\"] = 0\n                all_teams.append(team)\n\n            await self.config.teams.set(all_teams)\n            await asyncio.sleep(300)\n\n    async def save_game_state(self, data, time_to_game_start:str=\"0\"):\n        home = await self.get_team(data.home_team)\n        away = await self.get_team(data.away_team)\n        team_list = await self.config.teams()\n        team_list.remove(home)\n        team_list.remove(away)\n        if data.game_state != \"Final\":\n            if data.game_state == \"Preview\" and time_to_game_start != \"0\":\n                home[\"game_state\"] = data.game_state+time_to_game_start\n                away[\"game_state\"] = data.game_state+time_to_game_start\n            else:\n                home[\"game_state\"] = data.game_state\n                away[\"game_state\"] = data.game_state\n            home[\"period\"] = data.period\n            away[\"period\"] = data.period\n        else:\n            home[\"game_state\"] = \"Null\"\n            away[\"game_state\"] = \"Null\"\n            home[\"period\"] = 0\n            away[\"period\"] = 0\n        home[\"game_start\"] = data.game_start\n        away[\"game_start\"] = data.game_start\n        team_list.append(home)\n        team_list.append(away)\n        await self.config.teams.set(team_list)\n\n    async def post_time_to_game_start(self, data, time_left):\n        \"\"\"\n            Post when there is 60, 30, and 10 minutes until the game starts in all channels\n        \"\"\"\n        post_state = [\"all\", data.home_team, data.away_team]\n            \n        for channels in await self.config.all_channels():\n            channel = self.bot.get_channel(id=channels)\n            if channel is None:\n                continue\n\n            should_post = await self.check_to_post(channel, post_state)\n            team_to_post = await self.config.channel(channel).team()\n            if should_post and \"all\" not in team_to_post:\n                guild = channel.guild\n                msg = \"{} minutes until {} {} @ {} {} starts\".format(time_left, data.away_emoji, data.away_team,\n                       data.home_emoji, data.home_team)\n                try:\n                    await channel.send(msg)\n                except Exception as e:\n                    print(\"Problem posting in channel <#{}> : {}\".format(channels, e))\n\n    async def check_game_state(self, data):\n        post_state = [\"all\", data.home_team, data.away_team]\n        home = await self.get_team(data.home_team)\n        away = await self.get_team(data.away_team)\n        team_list = await self.config.teams()\n        # Home team checking\n\n        if data.game_state == \"Preview\":\n            \"\"\"Checks if the the game state has changes from Final to Preview\n               Could be unnecessary since after Game Final it will check for next game\n            \"\"\"\n            time_now = datetime.utcnow()\n            game_time = datetime.strptime(data.game_start, \"%Y-%m-%dT%H:%M:%SZ\")\n            game_start = (game_time - time_now).total_seconds()/60\n            if \"Preview\" not in home[\"game_state\"]:\n                \n                if not await self.config.created_gdc():\n                    try:\n                        await self.post_automatic_standings()\n                    except Exception as e:\n                        print(e)\n                    await self.check_new_gdc()\n                    await self.config.created_gdc.set(True)\n                await self.post_game_state(data)\n                await self.save_game_state(data)\n            if game_start < 60 and game_start > 30 and home[\"game_state\"] != \"Preview60\":\n                # Post 60 minutes until game start\n                await self.post_time_to_game_start(data, \"60\")\n                await self.save_game_state(data, \"60\")\n            if game_start < 30 and game_start >10 and home[\"game_state\"] != \"Preview30\":\n                # Post 30 minutes until game start\n                await self.post_time_to_game_start(data, \"30\")\n                await self.save_game_state(data, \"30\")\n            if game_start < 10 and game_start > 0 and home[\"game_state\"] != \"Preview10\":\n                # Post 10 minutes until game start\n                await self.post_time_to_game_start(data, \"10\")\n                await self.save_game_state(data, \"10\")\n\n                # Create channel and look for game day thread\n\n        if data.game_state == \"Live\":\n            \"\"\"Checks what the period is and posts the game is starting in the appropriate channel\"\"\"\n            if home[\"period\"] != data.period:\n                msg = \"**{} Period starting {} at {}**\"\n                print(msg.format(data.period_ord, data.away_team, data.home_team))\n                await self.post_game_state(data)\n                await self.save_game_state(data)\n\n            if (data.home_score + data.away_score) != 0:\n                # Check if there's goals only if there are goals\n                await self.check_team_goals(data)\n\n        if data.game_state == \"Final\":\n            \"\"\"Final game state checks\"\"\"\n            if (data.home_score + data.away_score) != 0:\n                \"\"\" Check for goal before posting game final, happens with OT games\"\"\"\n                await self.check_team_goals(data)\n            if home[\"game_state\"] != data.game_state and home[\"game_state\"] != \"Null\":\n                # Post game final data and check for next game\n                msg = \"Game Final {} @ {}\"\n                print(msg.format(data.home_team, data.away_team))\n                await self.post_game_state(data)\n                await self.save_game_state(data)\n\n    async def get_next_game(self, team):\n        \"\"\"Gets all NHL games this season or selected team\"\"\"\n        games_list = []\n        page_num = 0\n        today = datetime.now()\n        url = \"{base}/api/v1/schedule?startDate={year}-9-1&endDate={year2}-9-1\"\\\n              .format(base=self.url, year=get_season()[0], year2=get_season()[1])\n        url += \"&teamId={}\".format(self.teams[team][\"id\"])\n        async with self.session.get(url) as resp:\n            data = await resp.json()\n        for dates in data[\"dates\"]:\n            games_list += [game for game in dates[\"games\"]]\n        for game in games_list:\n            game_time = datetime.strptime(game[\"gameDate\"], \"%Y-%m-%dT%H:%M:%SZ\")\n            if game_time >= today:\n                page_num = games_list.index(game)\n                break\n        if games_list != []:\n            game = games_list[page_num]\n            async with self.session.get(\"https://statsapi.web.nhl.com\" + game[\"link\"]) as resp:\n                game_data = await resp.json()\n            game_data = await Game.from_json(game_data)\n            return game_data\n        else:\n            return None\n\n\n    async def check_team_goals(self, data):\n        \"\"\"\n            Checks to see if a goal needs to be posted\n        \"\"\"\n        home_team_data = await self.get_team(data.home_team)\n        away_team_data = await self.get_team(data.away_team)\n        all_data = await self.get_team(\"all\")\n        team_list = await self.config.teams()\n        post_state = [\"all\", data.home_team, data.away_team]\n        \n        home_goal_ids = [str(goal_id[\"result\"][\"eventCode\"]) for goal_id in data.home_goals]\n        away_goal_ids = [str(goal_id[\"result\"][\"eventCode\"]) for goal_id in data.away_goals]\n\n        home_goal_list = list(home_team_data[\"goal_id\"])\n        away_goal_list = list(away_team_data[\"goal_id\"])\n\n        for goal in data.goals:\n            goal_id = str(goal[\"result\"][\"eventCode\"])\n            team = goal[\"team\"][\"name\"]\n            team_data = await self.get_team(team)\n            if goal_id not in team_data[\"goal_id\"]:\n                # attempts to post the goal if there is a new goal\n                msg_list = await self.post_team_goal(goal, data)\n                team_list.remove(team_data)\n                team_data[\"goal_id\"][goal_id] = {\"goal\":goal,\"messages\":msg_list}\n                team_list.append(team_data)\n                await self.config.teams.set(team_list)\n                continue\n            if goal_id in team_data[\"goal_id\"]:\n                # attempts to edit the goal if the scorers have changed\n                old_goal = team_data[\"goal_id\"][goal_id][\"goal\"]\n                if goal[\"result\"][\"description\"] != old_goal[\"result\"][\"description\"]:\n                    old_msgs = team_data[\"goal_id\"][goal_id][\"messages\"]\n                    team_list.remove(team_data)\n                    team_data[\"goal_id\"][goal_id][\"goal\"] = goal\n                    team_list.append(team_data)\n                    await self.config.teams.set(team_list)\n                    await self.edit_team_goal(goal, data, old_msgs)\n        for goal in list(home_team_data[\"goal_id\"]):\n            # attempts to delete the goal if it was called back\n            await self.remove_goal_post(goal, data.home_team, data)\n        for goal in list(away_team_data[\"goal_id\"]):\n            await self.remove_goal_post(goal, data.away_team, data)\n\n    async def remove_goal_post(self, goal, team, data):\n        \"\"\"\n            Attempt to delete a goal if it was pulled back\n        \"\"\"\n        team_list = await self.config.teams()\n        team_data = await self.get_team(team)\n        if goal not in [goal[\"result\"][\"eventCode\"] for goal in data.goals]:\n            try:\n                old_msgs = team_data[\"goal_id\"][goal][\"messages\"].items()\n            except Exception as e:\n                print(e)\n                return\n            for channel_id, message_id in old_msgs:\n                channel = self.bot.get_channel(id=int(channel_id))\n                try:\n                    message = await channel.get_message(message_id)\n                    if message is not None:\n                        await message.delete()\n                    \n                except Exception as e:\n                    print(\"Cannot find message {} {}: {}\".format(team, goal, e))\n                    pass\n            try:\n                team_list.remove(team_data)\n                del team_data[\"goal_id\"][goal]\n                team_list.append(team_data)\n                await self.config.teams.set(team_list)\n            except Exception as e:\n                print(e)\n                return\n        return\n\n    async def check_to_post(self, channel, post_state):\n        channel_teams = await self.config.channel(channel).team()\n        should_post = False\n        for team in channel_teams:\n            if team in post_state:\n                should_post = True\n        return should_post\n\n    async def post_team_goal(self, goal, game_data):\n        \"\"\"\n            Creates embed and sends message if a team has scored a goal\n        \"\"\"\n        scorer = self.headshots.format(goal[\"players\"][0][\"player\"][\"id\"])\n        post_state = [\"all\", game_data.home_team, game_data.away_team]\n        event = goal[\"result\"][\"event\"]\n        msg_list = {}\n        if \"oilers\" in goal[\"team\"][\"name\"].lower() and \"missed\" not in event.lower():\n            try:\n                hue = Oilers(self.bot)\n                await hue.oilersgoal2()\n            except:\n                pass\n        for channels in await self.config.all_channels():\n            role = None\n            channel = self.bot.get_channel(id=channels)\n            if channel is None:\n                continue\n            should_post = await self.check_to_post(channel, post_state)\n            if should_post:\n                try:\n                    guild = channel.guild\n                    game_day_channels = await self.config.guild(guild).gdc()\n                    # Don't want to ping people in the game day channels\n                    if not channel.permissions_for(guild.me).embed_links:\n                        em = await goal_post_text(goal, game_data)\n                        msg = await channel.send(em)\n                        msg_list[str(channel.id)] = msg.id\n                        continue\n                    for roles in guild.roles:\n                        if roles.name == goal[\"team\"][\"name\"] + \" GOAL\":\n                            role = roles\n                    if game_day_channels is not None:\n                        # We don't want to ping people in the game day channels twice\n                        if channel.id in game_day_channels:\n                            role = None\n                    if role is None or \"missed\" in event.lower():\n                        em = await goal_post_embed(goal, game_data)\n                        msg = await channel.send(embed=em)\n                        msg_list[str(channel.id)] = msg.id\n                    else:\n                        em = await goal_post_embed(goal, game_data)\n                        msg = await channel.send(role.mention, embed=em)\n                        msg_list[str(channel.id)] = msg.id\n                except Exception as e:\n                    print(\"Could not post goal in {}: {}\".format(channels, e))\n                    pass\n        return msg_list\n\n    async def edit_team_goal(self, goal, game_data, og_msg):\n        \"\"\"\n            When a goal scorer has changed we want to edit the original post\n        \"\"\"\n        scorer = self.headshots.format(goal[\"players\"][0][\"player\"][\"id\"])\n        post_state = [\"all\", game_data.home_team, game_data.away_team]\n        event = goal[\"result\"][\"event\"]\n        em = await goal_post_embed(goal, game_data)\n        for channel_id, message_id in og_msg.items():\n            try:\n                role = None\n                channel = self.bot.get_channel(id=int(channel_id))\n                if channel is None:\n                    continue\n                if not channel.permissions_for(channel.guild.me).embed_links:\n                    continue\n                message = await channel.get_message(message_id)\n                guild = message.guild\n                game_day_channels = await self.config.guild(guild).gdc()\n                for roles in guild.roles:\n                    if roles.name == goal[\"team\"][\"name\"] + \" GOAL\":\n                        role = roles\n                if game_day_channels is not None:\n                        # We don't want to ping people in the game day channels twice\n                        if channel.id in game_day_channels:\n                            role = None\n                if role is None or \"missed\" in event.lower():\n                    await message.edit(embed=em)\n                else:  \n                    await message.edit(content=role.mention, embed=em)\n            except:\n                print(\"Could not edit goal in {}\".format(channel_id))\n        return\n\n    async def check_new_gdc(self):\n        print(\"Checking GDC\")\n        game_list = await self.get_day_games()\n        for guilds in await self.config.all_guilds():\n            guild = self.bot.get_guild(guilds)\n            if guild is None:\n                continue\n            if not await self.config.guild(guild).create_channels():\n                continue\n            team = await self.config.guild(guild).gdc_team()\n            if team != \"all\":\n                next_game = await self.get_next_game(team)\n                # print(next_game)\n                chn_name = await get_chn_name(next_game)\n                try:\n                    cur_channels = await self.config.guild(guild).gdc()\n                    cur_channel = self.bot.get_channel(cur_channels[0])\n                except Exception as e:\n                    print(e)\n                    cur_channel = None\n                if cur_channel is None:\n                    await self.create_gdc(guild)\n                elif cur_channel.name != chn_name.lower():\n                    await self.delete_gdc(guild)\n                    await self.create_gdc(guild)\n                \n            else:\n                await self.delete_gdc(guild)\n                for game in game_list:\n                    await self.create_gdc(guild, game)\n\n    async def create_gdc(self, guild, game_data=None):\n        \"\"\"\n            Creates a game day channel for the given game object\n            if no game object is passed it looks for the set team for the guild\n            returns None if not setup\n        \"\"\"\n        print(\"making Game Day channels\")\n        category = self.bot.get_channel(await self.config.guild(guild).category())\n        if category is None:\n            # Return none if there's no category to create the channel\n            return\n        if game_data is None:\n            team = await self.config.guild(guild).gdc_team()\n            \n            next_game = await self.get_next_game(team)\n        else:\n            team = game_data.home_team\n            next_game = game_data\n        if next_game is None:\n            return\n        chn_name = await get_chn_name(next_game)\n        new_chn = await guild.create_text_channel(chn_name, category=category)\n        cur_channels = await self.config.guild(guild).gdc()\n        if cur_channels is None:\n            cur_channels = []\n        cur_channels.append(new_chn.id)\n        await self.config.guild(guild).gdc.set(cur_channels)\n        await self.config.guild(guild).create_channels.set(True)\n        await self.config.channel(new_chn).team.set([team])\n        delete_gdc = await self.config.guild(guild).delete_gdc()\n        await self.config.channel(new_chn).to_delete.set(delete_gdc)\n\n        # Gets the timezone to use for game day channel topic\n        timestamp = datetime.strptime(next_game.game_start, \"%Y-%m-%dT%H:%M:%SZ\")\n        guild_team = await self.config.guild(guild).gdc_team()\n        channel_team = guild_team if guild_team != \"all\" else next_game.home_team\n        timezone = self.teams[channel_team][\"timezone\"]\n        time_string = utc_to_local(timestamp, timezone).strftime(\"%A %B %d, %Y at %I:%M %p %Z\")\n\n        game_msg = \"{} {} @ {} {} {}\".format(next_game.away_team, next_game.away_emoji,\\\n                                                   next_game.home_team, next_game.home_emoji,\\\n                                                   time_string)\n        await new_chn.edit(topic=game_msg)\n        if new_chn.permissions_for(guild.me).embed_links:\n            em = await game_state_embed(next_game)\n            preview_msg = await new_chn.send(embed=em)\n        else:\n            preview_msg = await new_chn.send(await game_state_text(next_game))\n\n        # Create new pickems object for the game\n        pickems = await self.config.guild(guild).pickems()\n        new_pickem = Pickems(preview_msg.id, new_chn.id, next_game.game_start,\n                             next_game.home_team, next_game.away_team, [])\n        pickems.append(new_pickem.to_json())\n        await self.config.guild(guild).pickems.set(pickems)\n        \n\n\n        if new_chn.permissions_for(guild.me).manage_messages:\n            await preview_msg.pin()\n        if new_chn.permissions_for(guild.me).add_reactions:\n            try:\n                await preview_msg.add_reaction(next_game.home_emoji[2:-1])\n                await preview_msg.add_reaction(next_game.away_emoji[2:-1])\n            except Exception as e:\n                print(e)\n\n    async def delete_gdc(self, guild):\n        \"\"\"\n            Deletes all game day channels in a given guild\n        \"\"\"\n        channels = await self.config.guild(guild).gdc()\n        for channel in channels:\n            chn = self.bot.get_channel(channel)\n            print(chn)\n            if chn is None:\n                try:\n                    await self.config._clear_scope(Config.CHANNEL, str(chn))\n                except:\n                    pass\n                continue\n            if not await self.config.channel(chn).to_delete():\n                continue\n            try:\n                await self.config.channel(chn).clear()\n                await chn.delete()\n            except Exception as e:\n                print(e)\n        await self.config.guild(guild).gdc.set([])\n\n    async def post_game_state(self, data):\n        \"\"\"\n            When a game state has changed this is called to create the embed\n            and post in all channels\n        \"\"\"\n        post_state = [\"all\", data.home_team, data.away_team]\n            \n        for channels in await self.config.all_channels():\n            channel = self.bot.get_channel(id=channels)\n            if channel is None:\n                continue\n\n            should_post = await self.check_to_post(channel, post_state)\n            if should_post:\n                guild = channel.guild\n                game_day_channels = await self.config.guild(guild).gdc()\n                if data.game_state == \"Live\":\n                    msg = \"**{} Period starting {} at {}**\"\n                    home_role, away_role = await get_team_role(guild, data.home_team, data.away_team)\n                    if game_day_channels is not None:\n                        # We don't want to ping people in the game day channels twice\n                        if channel.id in game_day_channels:\n                            home_role, away_role = data.home_team, data.away_team\n                    try:\n                        if not channel.permissions_for(guild.me).embed_links:\n                            em = await game_state_text(data)\n                            await channel.send(msg.format(data.period_ord, away_role, home_role)+\"\\n{}\".format(em))\n                        else:\n                            em = await game_state_embed(data)\n                            await channel.send(msg.format(data.period_ord, away_role, home_role), embed=em)\n                    except Exception as e:\n                            print(\"Problem posting in channel <#{}> : {}\".format(channels, e)) \n                \n                else:\n                    if data.game_state == \"Preview\":\n                        print(data.game_state)\n                        if game_day_channels is not None:\n                            # Don't post the preview message twice in the channel\n                            if channel.id in game_day_channels:\n                                continue\n                    try:\n                        if not channel.permissions_for(guild.me).embed_links:\n                            await channel.send(await game_state_text(data))\n                        else:\n                            await channel.send(embed=await game_state_embed(data))\n                    except Exception as e:\n                        print(\"Problem posting in channel <#{}> : {}\".format(channels, e))\n\n\n    async def post_automatic_standings(self):\n        \"\"\"\n            Automatically update a standings embed with the latest stats\n            run when new games for the day is updated\n        \"\"\"\n        print(\"Updating Standings.\")\n        all_guilds = await self.config.all_guilds()\n        for guilds in all_guilds:\n            try:\n                guild = self.bot.get_guild(guilds)\n                print(guild.name)\n            except:\n                continue\n            if await self.config.guild(guild).post_standings():\n\n                search = await self.config.guild(guild).standings_type()\n                if search is None:\n                    continue\n                standings_channel = await self.config.guild(guild).standings_channel()\n                if standings_channel is None:\n                    continue\n                channel = self.bot.get_channel(standings_channel)\n                if channel is None:\n                    continue\n                standings_msg = await self.config.guild(guild).standings_msg()\n                if standings_msg is None:\n                    continue\n                message = await channel.get_message(standings_msg)\n\n                standings, page = await get_team_standings(search)\n                if search != \"all\":\n                    em = await build_standing_embed(await get_team_standings(search))\n                else:\n                    em = await all_standing_embed(await get_team_standings(search))\n                if message is not None:\n                    await message.edit(embed=em)\n\n    async def get_team_channels(self, team):\n        for teams in await self.config.teams():\n            if teams[\"team_name\"] == team:\n                return teams[\"channel\"]\n        return []\n\n    async def get_team(self, team):\n        return_team = None\n        team_list = await self.config.teams()\n        for teams in team_list:\n            if team == teams[\"team_name\"]:\n                return_team = team\n                return teams\n        if return_team is None:\n            # Add unknown teams to the config to track stats\n            return_team = TeamEntry(\"Null\", team, 0, [], {}, [], \"\")\n            team_list.append(return_team.to_json())\n            await self.config.teams.set(team_list)\n            return await self.get_team(team)\n\n    async def on_raw_reaction_add(self, payload):\n        channel = self.bot.get_channel(id=payload.channel_id)\n        try:\n            guild = channel.guild\n        except:\n            return\n        pickems_list = await self.config.guild(guild).pickems()\n        pickems = [Pickms.from_json(p) for p in pickems_list]\n        if len(pickems) == 0:\n            return\n        try:\n            msg = await channel.get_message(id=payload.message_id)\n        except:\n            return        \n        user = guild.get_member(payload.user_id)\n        if user.bot:\n            return\n        is_pickems_vote = False\n        for pickem in pickems:\n            if pickem.message == msg.id:\n                \n\n\n\n\n\n    ##############################################################################\n    # Here are all the command functions to set certain attributes and settings\n\n    @commands.group(name=\"hockey\", aliases=[\"nhl\"])\n    async def hockey_commands(self, ctx):\n        \"\"\"Various Hockey related commands also aliased to `nhl`\"\"\"\n        pass\n\n    @commands.group()\n    @checks.admin_or_permissions(manage_channels=True)\n    async def gdc(self, ctx):\n        \"\"\"Game Day Channel setup for the server\"\"\"\n        if ctx.invoked_subcommand is None:\n            guild = ctx.message.guild\n            create_channels = await self.config.guild(guild).create_channels()\n            if create_channels is None:\n                return\n            team = await self.config.guild(guild).gdc_team()\n            if team is None:\n                team = \"None\"\n            channels = await self.config.guild(guild).gdc()\n            category = self.bot.get_channel(await self.config.guild(guild).category())\n            delete_gdc = await self.config.guild(guild).delete_gdc()\n            if category is not None:\n                category = category.name\n            if channels is not None:\n                created_channels = \"\"\n                for channel in channels:\n                    chn = self.bot.get_channel(channel)\n                    if chn is not None:\n                        created_channels += chn.mention\n                    else:\n                        created_channels += \"<#{}>\\n\".format(channel)\n                if len(channels) == 0:\n                    created_channels = \"None\"\n            else:\n                created_channels = \"None\"\n            if not ctx.channel.permissions_for(guild.me).embed_links:\n                msg = \"\"\"GDC settings for {}\\nCreate Game Day Channels:**{}**\\nDelete Game Day Channels: **{}**\\nTeam: **{}**\\nCurrent Channels: {}\n                \"\"\".format(guild.name, create_channels, delete_gdc, team, created_channels)\n            if ctx.channel.permissions_for(guild.me).embed_links:\n                em = discord.Embed(title=\"GDC settings for {}\".format(guild.name))\n                em.add_field(name=\"Create Game Day Channels\", value=str(create_channels), inline=False)\n                em.add_field(name=\"Delete Game Day Channels\", value=str(delete_gdc), inline=False)\n                em.add_field(name=\"Team\", value=str(team), inline=False)\n                em.add_field(name=\"Current Channels\", value=created_channels, inline=False)\n                await ctx.send(embed=em)\n            else:\n                await ctx.send(msg)\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def lights(self, ctx):\n        hue = Oilers(self.bot)\n        await hue.oilersgoal2()\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def reset(self, ctx):\n        all_teams = await self.config.teams()\n        for team in await self.config.teams():\n            all_teams.remove(team)\n            team[\"goal_id\"] = {}\n            team[\"game_state\"] = \"Null\"\n            team[\"game_start\"] = \"\"\n            team[\"period\"] = 0\n            all_teams.append(team)\n\n        await self.config.teams.set(all_teams)\n        await ctx.send(\"Done.\")\n\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def add_team_data(self, ctx):\n        all_teams = await self.config.teams()\n        print(all_teams)\n        for team in teams:\n            if team not in [t[\"team_name\"] for t in all_teams]:\n                team_entry = TeamEntry(\"Null\", team, 0, [], {}, [], \"\")\n                all_teams.append(team_entry.to_json())\n        if \"all\" not in all_teams:\n            team_entry = TeamEntry(\"Null\", \"all\", 0, [], {}, [], \"\")\n            all_teams.append(team_entry.to_json())\n        await self.config.teams.set(all_teams)\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def testhockey(self, ctx):\n        for channels in await self.config.all_channels():\n            channel = self.bot.get_channel(channels)\n            if channel is None:\n                await self.config._clear_scope(Config.CHANNEL, str(channels))\n                print(channels)\n                continue\n            chn = await self.config.channel(channel).team()\n            print(chn)\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def cleargdc(self, ctx):\n        guild = ctx.message.guild\n        good_channels = []\n        for channels in await self.config.guild(guild).gdc():\n            channel = self.bot.get_channel(channels)\n            if channel is None:\n                await self.config._clear_scope(Config.CHANNEL, str(channels))\n                print(channels)\n                continue\n            else:\n                good_channels.append(channel.id)\n        await self.config.guild(guild).gdc.set(good_channels)\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def clear_broken_channels(self, ctx):\n        for channels in await self.config.all_channels():\n            channel = self.bot.get_channel(channels)\n            if channel is None:\n                await self.config._clear_scope(Config.CHANNEL, str(channels))\n                print(channels)\n                continue\n            # if await self.config.channel(channel).to_delete():\n                # await self.config._clear_scope(Config.CHANNEL, str(channels))\n        await ctx.send(\"done\")\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def remove_broken_guild(self, ctx):\n        all_guilds = await self.config.all_guilds()\n        for guilds in await self.config.all_guilds():\n            guild = self.bot.get_guild(guilds)\n            if guild is None:\n                await self.config._clear_scope(Config.GUILD, str(guilds))\n            else:\n                if not await self.config.guild(guild).create_channels():\n                    await self.config.guild(guild).gdc.set([])\n\n        await ctx.send(\"Done.\")\n\n    @hockey_commands.command(hidden=True)\n    @checks.is_owner()\n    async def cogstats(self, ctx):\n        all_channels = await self.config.all_channels()\n        all_guilds = await self.config.all_guilds()\n        guild_list = {}\n        for channels in all_channels.keys():\n            channel = self.bot.get_channel(channels)\n            if channel is None:\n                print(channels)\n                continue\n            if channel.guild.name not in guild_list:\n                guild_list[channel.guild.name] = 1\n            else:\n                guild_list[channel.guild.name] += 1\n        msg = \"Servers:{}\\nNumber of Channels: {}\\nNumber of Servers: {}\".format(\n               guild_list, len(all_channels), len(all_guilds))\n        print(guild_list)\n        print(len(all_channels))\n        print(len(all_guilds))\n\n\n        await ctx.send(\"Done.\")\n\n\n    @gdc.command(name=\"delete\")\n    async def gdc_delete(self, ctx, guild_id:discord.Guild=None):\n        \"\"\"\n            Delete all current game day channels for the server\n        \"\"\"\n        if guild_id is None:\n            guild_id = ctx.message.guild\n\n        if await self.config.guild(guild_id).create_channels():\n            await self.delete_gdc(guild_id)\n        await ctx.send(\"Done.\")\n\n    @gdc.command(name=\"create\")\n    async def gdc_create(self, ctx, guild_id:discord.Guild=None):\n        \"\"\"\n            Creates the next gdc for the server\n        \"\"\"\n        if guild_id is None:\n            guild_id = ctx.message.guild\n\n        if await self.config.guild(guild_id).create_channels():\n            await self.create_gdc(guild_id)\n        await ctx.send(\"Done.\")\n\n    @gdc.command(name=\"toggle\")\n    async def gdc_toggle(self, ctx):\n        \"\"\"\n            Toggles the game day channel creation on this server\n        \"\"\"\n        guild = ctx.message.guild\n        cur_setting = await self.config.guild(guild).create_channels()\n\n        msg = \"Okay, game day channels {} be created on this server.\"\n        verb = \"won't\" if cur_setting else \"will\"\n        await self.config.guild(guild).create_channels.set(not cur_setting)\n        await ctx.send(msg.format(verb))\n\n    @gdc.command(name=\"category\")\n    async def gdc_category(self, ctx, category:discord.CategoryChannel):\n        \"\"\"\n            Change the category for channel creation. Channel is case sensitive.\n        \"\"\"\n        guild = ctx.message.guild\n\n        cur_setting = await self.config.guild(guild).category()\n\n        msg = \"Okay, game day channels be created in the {} category.\"\n        await self.config.guild(guild).category.set(category.id)\n        await ctx.send(msg.format(category.name))\n\n    @gdc.command(name=\"autodelete\")\n    async def gdc_autodelete(self, ctx):\n        \"\"\"\n            Toggle's auto deletion of game day channels.\n        \"\"\"\n        guild = ctx.message.guild\n\n        cur_setting = await self.config.guild(guild).delete_gdc()\n\n        msg = \"Okay, game day channels {} be deleted on this server.\\nNote, this may not happen until the next set of games.\"\n        verb = \"won't\" if cur_setting else \"will\"\n        await self.config.guild(guild).delete_gdc.set(not cur_setting)\n        await ctx.send(msg.format(verb))\n\n\n    @gdc.command(hidden=True, name=\"test\")\n    @checks.is_owner()\n    async def test_gdc(self, ctx):\n        await self.check_new_gdc()\n\n\n    @gdc.command(name=\"setup\")\n    async def gdc_setup(self, ctx, team, category:discord.CategoryChannel=None, delete_gdc:bool=True):\n        \"\"\"\n            Setup game day channels for a single team or all teams\n            Use quotes to specify the full team name and category if required\n        \"\"\"\n        guild = ctx.message.guild\n        if category is None:\n            category = guild.get_channel(ctx.message.channel.category_id)\n        if not category.permissions_for(guild.me).manage_channels:\n            await ctx.send(\"I don't have permission to create or delete channels!\")\n            return\n        team_list = await check_valid_team(team)\n        if team_list == [] and team.lower() != \"all\":\n            await ctx.send(\"{} is not a valid team!\".format(team))\n            return\n        if len(team_list) > 1:\n            team = await self.pick_team(ctx, team_list)\n        else:\n            team = team_list[0]\n\n        await self.config.guild(guild).category.set(category.id)\n        await self.config.guild(guild).gdc_team.set(team)\n        await self.config.guild(guild).delete_gdc.set(delete_gdc)\n        if team.lower() != \"all\":\n            await self.create_gdc(guild)\n        else:\n            game_list = await self.get_day_games()\n            for game in game_list:\n                await self.create_gdc(guild, game)\n        await ctx.send(\"Game Day Channels for {} setup in the {} category\".format(team, category.name))\n\n\n    @hockey_commands.command(name=\"poststandings\", aliases=[\"poststanding\"])\n    async def post_standings(self, ctx, standings_type:str, channel:discord.TextChannel=None):\n        \"\"\"Posts automatic standings when all games for the day are done\"\"\"\n        guild = ctx.message.guild\n        if channel is None:\n            channel = ctx.message.channel\n        standings_list = [\"metropolitan\", \"atlantic\", \"pacific\", \"central\", \"eastern\", \"western\", \"all\"]\n        if standings_type.lower() not in standings_list:\n            await ctx.send(\"You must choose from {}\".format(\", \".join(s for s in standings_list)))\n            return\n        await self.config.guild(guild).standings_type.set(standings_type)\n        await self.config.guild(guild).standings_channel.set(channel.id)\n        await ctx.send(\"Sending standings to {}\".format(channel.mention))\n\n        async with self.session.get(\"https://statsapi.web.nhl.com/api/v1/standings\") as resp:\n            data = await resp.json()\n        conference = [\"eastern\", \"western\"]\n        division = [\"metropolitan\", \"atlantic\", \"pacific\", \"central\"]\n        division_data = []\n        conference_data = []\n        eastern = [team for record in data[\"records\"] for team in record[\"teamRecords\"] if record[\"conference\"][\"name\"] ==\"Eastern\"]\n        western = [team for record in data[\"records\"] for team in record[\"teamRecords\"] if record[\"conference\"][\"name\"] ==\"Western\"]\n        conference_data.append(eastern)\n        conference_data.append(western)\n        division_data = [record for record in data[\"records\"]]\n\n        if standings_type in division:\n            division_search = None\n            for record in division_data:\n                if standings_type.lower() == record[\"division\"][\"name\"].lower():\n                    division_search = record\n            index = division_data.index(division_search)\n            em = await division_standing_embed(division_data, index)\n        elif standings_type.lower() in conference:\n            if standings_type.lower() == \"eastern\":\n                em = await conference_standing_embed(conference_data, 0)\n            else:\n                em = await conference_standing_embed(conference_data, 1)\n        elif standings_type == \"all\":\n            em = await all_standing_embed(division_data, 0)\n        message = await channel.send(embed=em)\n        await self.config.guild(guild).standings_msg.set(message.id)\n        await ctx.send(\"{} standings will now be automatically updated in {}\".format(standings_type, channel.mention))\n        await self.config.guild(guild).post_standings.set(True)\n\n\n    @hockey_commands.command()\n    async def togglestandings(self, ctx):\n        \"\"\"Toggles the standings on or off.\"\"\"\n        guild = ctx.message.guild\n        cur_state = not await self.config.guild(guild).post_standings()\n        await self.config.guild(guild).post_standings.set(cur_state)\n        await ctx.send(\"Done.\")\n\n    @hockey_commands.command(name=\"add\", aliases=[\"add_goals\"])\n    @checks.admin_or_permissions(manage_channels=True)\n    async def add_goals(self, ctx, team, channel:discord.TextChannel=None):\n        \"\"\"Adds a hockey team goal updates to a channel do 'all' for all teams\"\"\"\n        all_team_data = await self.config.teams()\n        guild = ctx.message.guild\n        team_name = await check_valid_team(team)\n        if team_name == []:\n            await ctx.send(\"{} is not an available team!\".format(team))\n            return\n        if len(team_name) > 1:\n                team_name = await pick_team(ctx, team_name)\n        else:\n            team_name = team_name[0]\n        # team_data = await self.get_team(team)\n        if channel is None:\n            channel = ctx.message.channel\n        if not channel.permissions_for(guild.me).embed_links:\n            await ctx.send(\"I need embed_links enabled to post goal messages!\")\n            return\n        await self.config.channel(channel).team.set(team_name)\n        await ctx.send(\"{} goals will be posted in {}\".format(team_name, channel.mention))\n\n\n    @hockey_commands.command(name=\"del\", aliases=[\"remove\", \"rem\"])\n    @checks.admin_or_permissions(manage_channels=True)\n    async def remove_goals(self, ctx, channel:discord.TextChannel=None):\n        \"\"\"Removes a teams goal updates from a channel\"\"\"\n        if channel is None:\n            channel = ctx.message.channel\n    \n        await self.config.channel(channel).clear()\n        await ctx.send(\"goals will stop being posted in {}\".format(channel.mention))\n\n    @hockey_commands.command(pass_context=True, name=\"role\")\n    async def team_role(self, ctx, *, team):\n        \"\"\"Set your role to a team role\"\"\"\n        guild = ctx.message.guild\n        try:\n            role = [role for role in guild.roles if (team.lower() in role.name.lower() and \"GOAL\" not in role.name)][0]\n            await ctx.message.author.add_roles(role)\n            await ctx.message.channel.send( \"Role applied.\")\n        except:\n            await ctx.message.channel.send( \"{} is not an available role!\".format(team))\n\n    @hockey_commands.command(name=\"goals\")\n    async def team_goals(self, ctx, *, team=None):\n        \"\"\"Subscribe to goal notifications\"\"\"\n        guild = ctx.message.guild\n        member = ctx.message.author\n        if team is None:\n            team = [role.name for role in member.roles if role.name in self.teams]\n            for t in team:\n                roles = [role for role in guild.roles if role.name == t + \" GOAL\"]\n                for role in roles:\n                    await ctx.message.author.add_roles(role)\n                await ctx.message.channel.send( \"Role applied.\")\n        else:\n            try:\n                role = [role for role in guild.roles if (team.lower() in role.name.lower() and role.name.endswith(\"GOAL\"))][0]\n                await ctx.message.author.add_roles(role)\n                await ctx.message.channel.send( \"Role applied.\")\n            except:\n                await ctx.message.channel.send(\"{} is not an available role!\".format(team))\n\n    @hockey_commands.command()\n    async def standings(self, ctx, *, search=None):\n        \"\"\"Displays current standings for each division\"\"\"\n        if search is None:\n            standings, page = await get_team_standings(\"division\")\n            await hockey_menu(ctx, \"standings\", standings)\n            return\n        search_r = await check_valid_team(search, True)\n        if search_r == []:\n            await ctx.message.channel.send( \"{} Does not appear to be a valid standing type!\".format(search))\n            return\n        if len(search_r) > 1:\n            search_r = await pick_team(ctx, search)\n        else:\n            search_r = search_r[0]\n\n        standings, page = await get_team_standings(search_r.lower())\n        if search != \"all\":\n            await hockey_menu(ctx, \"standings\", standings, None, page)\n        else:\n            await hockey_menu(ctx, \"all\", standings, None, page) \n\n\n    @hockey_commands.command(aliases=[\"score\"])\n    async def games(self, ctx, *, team=None):\n        \"\"\"Gets all NHL games this season or selected team\"\"\"\n        games_list = []\n        page_num = 0\n        today = datetime.now()\n        url = \"{base}/api/v1/schedule?startDate={year}-9-1&endDate={year2}-9-1\"\\\n              .format(base=self.url, year=get_season()[0], year2=get_season()[1])\n        \n        if team is not None:\n            team_search = await check_valid_team(team)\n            if team_search == []:\n                await ctx.message.channel.send( \"{} Does not appear to be an NHL team!\".format(team))\n                return\n            if len(team_search) > 1:\n                team = await pick_team(ctx, team_search)\n            else:\n                team = team_search[0]\n            url += \"&teamId={}\".format(self.teams[team][\"id\"])\n        async with self.session.get(url) as resp:\n            data = await resp.json()\n        for dates in data[\"dates\"]:\n            games_list += [game for game in dates[\"games\"]]\n        for game in games_list:\n            game_time = datetime.strptime(game[\"gameDate\"], \"%Y-%m-%dT%H:%M:%SZ\")\n            if game_time >= today:\n                page_num = games_list.index(game)\n                break\n        if games_list != []:\n            await hockey_menu(ctx, \"game\", games_list, None, page_num)\n        else:\n            await ctx.message.channel.send( \"{} have no recent or upcoming games!\".format(team))\n\n    @hockey_commands.command(aliases=[\"player\"])\n    async def players(self, ctx, *, search):\n        \"\"\"Gets the current team roster\"\"\"\n        rosters = {}\n        players = []\n        teams = [team for team in self.teams if search.lower() in team.lower()]\n        if teams != []:\n            for team in teams:\n                url = \"{}/api/v1/teams/{}/roster\".format(self.url, self.teams[team][\"id\"])\n                async with self.session.get(url) as resp:\n                    data = await resp.json()\n                for player in data[\"roster\"]:\n                    players.append(player)\n        else:\n            for team in self.teams:\n                url = \"{}/api/v1/teams/{}/roster\".format(self.url, self.teams[team][\"id\"])\n                async with self.session.get(url) as resp:\n                    data = await resp.json()\n                try:\n                    rosters[team] = data[\"roster\"]\n                except KeyError:\n                    pass\n            \n            for team in rosters:\n                for player in rosters[team]:\n                    if search.lower() in player[\"person\"][\"fullName\"].lower():\n                        players.append(player)\n        \n        if players != []:\n            await hockey_menu(ctx, \"roster\", players)\n        else:\n            await ctx.message.channel.send( \"{} is not an NHL team or Player!\".format(search))\n\n    @hockey_commands.command(hidden=True)\n    @checks.mod_or_permissions(manage_messages=True)\n    async def rules(self, ctx):\n        if not ctx.channel.permissions_for(ctx.guild.me).embed_links:\n            return\n        rules = await self.config.guild(ctx.guild).rules()\n        team = await self.config.guild(ctx.guild).team_rules()\n        if rules == \"\":\n            return\n        em = await make_rules_embed(ctx.guild, team, rules)\n        if ctx.channel.permissions_for(ctx.guild.me).manage_messages:\n            await ctx.message.delete()\n        await ctx.send(embed=em)\n\n    @hockey_commands.command(hidden=True)\n    @checks.mod_or_permissions(manage_messages=True)\n    async def setrules(self, ctx, team, *, rules):\n        \"\"\"Set the main rules page for the nhl rules command\"\"\"\n        if not ctx.channel.permissions_for(ctx.guild.me).embed_links:\n            await ctx.send(\"I need embed_links for this to work.\")\n            return\n        team_search = await check_valid_team(team)\n        if team_search == []:\n            await ctx.message.channel.send( \"{} Does not appear to be an NHL team!\".format(team))\n            return\n        if len(team_search) > 1:\n            team = await pick_team(ctx, team_search)\n        else:\n            team = team_search[0]\n        await self.config.guild(ctx.guild).rules.set(rules)\n        await self.config.guild(ctx.guild).team_rules.set(team)\n        em = await make_rules_embed(ctx.guild, team, rules)\n        await ctx.send(\"Done, here's how it will look.\", embed=em)\n\n    @hockey_commands.command(aliases=[\"link\", \"invite\"])\n    async def otherdiscords(self, ctx, team):\n        \"\"\"Gets the Specified teams discord server link\"\"\"\n        if team not in [\"all\", \"page\"]:\n            team_search = await check_valid_team(team)\n            if team_search == []:\n                await ctx.message.channel.send( \"{} Does not appear to be an NHL team!\".format(team))\n                return\n            if len(team_search) > 1:\n                team = await pick_team(ctx, team_search)\n            else:\n                team = team_search[0]\n            await ctx.send(teams[team][\"invite\"])\n        else:\n            if not ctx.channel.permissions_for(ctx.message.author).manage_messages:\n                # Don't need everyone spamming this command\n                return\n            atlantic = [team for team in teams if teams[team][\"division\"] == \"Atlantic\"]\n            metropolitan = [team for team in teams if teams[team][\"division\"] == \"Metropolitan\"]\n            central = [team for team in teams if teams[team][\"division\"] == \"Central\"]\n            pacific = [team for team in teams if teams[team][\"division\"] == \"Pacific\"]\n            team_list = {\"Atlantic\":atlantic, \"Metropolitan\":metropolitan, \"Central\":central, \"Pacific\":pacific}\n            msg1 = \"__**Hockey Discord Master List**__\\n```fix\\n- Do not join other discords to troll.\\n- Respect their rules & their members (Yes even the leafs & habs unfortunately).\\n- We don't control the servers below. If you get banned we can not get you unbanned.\\n- Don't be an asshole because then we all look like assholes. They won't see it as one asshole fan they will see it as a toxic fanbase.\\n- Salt levels may vary. Your team is the best here but don't go on another discord and preach it to an angry mob after we just won.\\n- Not following the above rules will result in appropriate punishments ranging from a warning to a ban. ```\\n\\nhttps://discord.gg/reddithockey\"\n            eastern_conference = \"https://i.imgur.com/CtXvcCs.png\"\n            western_conference = \"https://i.imgur.com/UFYJTDF.png\"\n            async with self.session.get(eastern_conference) as resp:\n                data = await resp.read()\n            logo = BytesIO()\n            logo.write(data)\n            logo.seek(0)\n            image = discord.File(logo, filename=\"eastern_logo.png\")\n            await ctx.send(msg1, file=image)\n            for division in team_list:\n                if division == \"Central\":\n                    async with self.session.get(western_conference) as resp:\n                        data = await resp.read()\n                    logo = BytesIO()\n                    logo.write(data)\n                    logo.seek(0)\n                    image = discord.File(logo, filename=\"western_logo.png\")\n                    await ctx.send(file=image)\n                div_emoji = \"<:\" + teams[\"Team {}\".format(division)][\"emoji\"] + \">\"\n                msg = \"{0} __**{1} DIVISION**__ {0}\".format(div_emoji, division.upper())\n                await ctx.send(msg)\n                for team in team_list[division]:\n                    team_emoji = \"<:\" + teams[team][\"emoji\"] + \">\"\n                    team_link = teams[team][\"invite\"]\n                    msg = \"{0} {1} {0}\".format(team_emoji, team_link)\n                    await ctx.send(msg)\n\n    def __unload(self):\n        self.bot.loop.create_task(self.session.close())\n        self.loop.cancel()\n\n    __del__ = __unload\n",
			"file": "hockey/hockey.py",
			"file_size": 58107,
			"file_write_time": 131829249105869131,
			"settings":
			{
				"buffer_size": 56887,
				"line_ending": "Windows"
			}
		},
		{
			"file": "hockey/game.py",
			"settings":
			{
				"buffer_size": 4402,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "from .teams import teams\n\n\nclass Pickems:\n    def __init__(self, message:int, channel:int, game_start:str, home_team:str, away_team:str, votes:list):\n        super().__init__()\n        self.message = message\n        self.channel = channel\n        self.game_start = game_start\n        self.home_team = home_team\n        self.away_team = away_team\n        self.votes = votes\n        self.home_emoji = \"{}\".format(teams[home_team][\"emoji\"]) if home_team in teams else \"<:nhl:496510372828807178>\"\n        self.away_emoji = \"{}\".format(teams[away_team][\"emoji\"]) if away_team in teams else \"<:nhl:496510372828807178>\"\n\n    def add_vote(self, user_id, team):\n        for user, choice in self.votes:\n            if user == user_id:\n                \n\n    def to_json(self) -> dict:\n        return {\n            \"message\" : self.message,\n            \"channel\" : self.channel,\n            \"game_start\" : self.game_start,\n            \"home_team\" : self.home_team,\n            \"away_team\" : self.away_team,\n            \"votes\" : self.votes\n        }\n\n    @classmethod\n    def from_json(cls, data: dict):\n        return cls(data[\"message\"], data[\"channel\"], data[\"game_start\"],\n                   data[\"home_team\"], data[\"away_team\"], data[\"votes\"])",
			"file": "hockey/pickems.py",
			"file_size": 1135,
			"file_write_time": 131829239696521273,
			"settings":
			{
				"buffer_size": 1236,
				"line_ending": "Windows"
			}
		},
		{
			"file": "starboard/starboard.py",
			"settings":
			{
				"buffer_size": 15509,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 170.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"git push",
				"Git: Push"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"disco",
				"Package Control: Discover Packages"
			],
			[
				"git pull",
				"Git: Pull"
			],
			[
				"git status",
				"Git: Status"
			],
			[
				"git: ",
				"Git: Fetch"
			],
			[
				"git swi",
				"Git: Switch Repo"
			],
			[
				"package control remove",
				"Package Control: Remove Package"
			],
			[
				"package control",
				"Package Control: Install Package"
			],
			[
				"package control install",
				"Package Control: Install Package"
			],
			[
				"package control: remove",
				"Package Control: Remove Package"
			],
			[
				"git",
				"Git: Reset (hard) HEAD"
			],
			[
				"git:",
				"Git: Status"
			],
			[
				"package",
				"Package Control: Upgrade/Overwrite All Packages"
			],
			[
				"git bra",
				"Git: Change Branch"
			],
			[
				"git stat",
				"Git: Status"
			]
		],
		"width": 444.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/E/github/Trusty-cogs",
		"/E/github/Trusty-cogs/__pycache__",
		"/E/github/Trusty-cogs/hockey",
		"/E/github/Trusty-cogs/starboard",
		"/E/github/Trusty-cogs/twitch"
	],
	"file_history":
	[
		"/E/github/Trusty-cogs/twitch/twitch.py",
		"/E/github/Trusty-cogs/twitch/twitch_follower.py",
		"/E/github/Trusty-cogs/twitch/twitch_profile.py",
		"/E/github/Trusty-cogs/hockey/hockey.py",
		"/E/github/Trusty-cogs/hockey/embeds.py",
		"/E/github/Trusty-cogs/hockey/game.py",
		"/C/Users/Damez/AppData/Roaming/Sublime Text 3/Packages/Package Control/Package Control.sublime-settings",
		"/E/github/Trusty-cogs/trusty-cogs.sublime-project",
		"/C/Users/Damez/Desktop/Events.xml",
		"/E/github/Trusty-cogs/cleverbot/cleverbot.py",
		"/E/github/Trusty-cogs/activity/activity.py",
		"/E/github/Trusty-cogs/addimage/addimage.py",
		"/E/github/Trusty-cogs/anime/anime.py",
		"/E/github/Trusty-cogs/autorole/autorole.py",
		"/E/github/Trusty-cogs/backup/backup.py",
		"/E/github/Trusty-cogs/badges/badges.py",
		"/E/github/Trusty-cogs/blockchain/blockchain.py",
		"/E/github/Trusty-cogs/chatter/chatter.py",
		"/E/github/Trusty-cogs/compliment/compliment.py",
		"/E/github/Trusty-cogs/conversions/conversions.py",
		"/E/github/Trusty-cogs/covfefe/covfefe.py",
		"/E/github/Trusty-cogs/decode/decode.py",
		"/E/github/Trusty-cogs/dev/dev.py",
		"/E/github/Trusty-cogs/emojireact/emojireact.py",
		"/E/github/Trusty-cogs/faces/faces.py",
		"/E/github/Trusty-cogs/fun/fun.py",
		"/E/github/Trusty-cogs/gab/gab.py",
		"/E/github/Trusty-cogs/halo/halo.py",
		"/E/github/Trusty-cogs/hue/hue.py",
		"/E/github/Trusty-cogs/imagemaker/imagemaker.py",
		"/E/github/Trusty-cogs/imgflip/imgflip.py",
		"/E/github/Trusty-cogs/insult/insult.py",
		"/E/github/Trusty-cogs/juche/juche.py",
		"/E/github/Trusty-cogs/mock/mock.py",
		"/E/github/Trusty-cogs/modlogs/modlogs.py",
		"/E/github/Trusty-cogs/notsobot/notsobot.py",
		"/E/github/Trusty-cogs/qposts/qposts.py",
		"/E/github/Trusty-cogs/rekt/rekt.py",
		"/E/github/Trusty-cogs/runescape/runescape.py",
		"/E/github/Trusty-cogs/serverstats/serverstats.py",
		"/E/github/Trusty-cogs/serverwhitelist/serverwhitelist.py",
		"/E/github/Trusty-cogs/starboard/starboard.py",
		"/E/github/Trusty-cogs/stickyroles/stickyroles.py",
		"/E/github/Trusty-cogs/tarot/tarotreading.py",
		"/E/github/Trusty-cogs/translate/translate.py",
		"/E/github/Trusty-cogs/triggersize/triggersize.py",
		"/E/github/Trusty-cogs/trustyavatar/trustyavatar.py",
		"/E/github/Trusty-cogs/trustybot/trustybot.py",
		"/E/github/Trusty-cogs/tweets/tweets.py",
		"/E/github/Trusty-cogs/unity4j/unity4j.py",
		"/E/github/Trusty-cogs/weather/weather.py",
		"/E/github/Trusty-cogs/welcome/welcome.py",
		"/E/github/Trusty-cogs/notsobot/vw/macintoshplus.py",
		"/E/github/Trusty-cogs/badges/__init__.py",
		"/E/github/NotSoBot-master/bot.py",
		"/E/github/NotSoBot-master/utils/funcs.py",
		"/E/github/NotSoBot-master/bot0.py",
		"/E/github/NotSoBot-master/mods/Info.py",
		"/E/github/NotSoBot-master/message_queue_bot.py",
		"/E/github/NotSoBot-master/utils/checks.py",
		"/E/github/NotSoBot-master/pixelsort/util.py",
		"/E/github/NotSoBot-master/mods/Markov.py",
		"/E/github/NotSoBot-master/mods/AI.py",
		"/E/github/NotSoBot-master/mods/Chan.py",
		"/E/github/NotSoBot-master/mods/Wc.py",
		"/E/github/NotSoBot-master/mods/Utils.py",
		"/E/github/NotSoBot-master/mods/Changes.py",
		"/E/github/NotSoBot-master/mods/cog.py",
		"/E/github/NotSoBot-master/message_queue_api.py",
		"/E/github/Trusty-cogs/notsobot/info.json",
		"/E/github/NotSoBot-master/vw/macintoshplus.py",
		"/E/github/Trusty-cogs/notsobot/__init__.py",
		"/E/github/Trusty-cogs/cleverbot/__init__.py",
		"/E/github/Trusty-cogs/README.md",
		"/E/github/Trusty-cogs/triggersize/__init__.py",
		"/E/github/Trusty-cogs/triggersize/info.json",
		"/E/github/Trusty-cogs/reee/__init__.py",
		"/E/github/Trusty-cogs/reee/triggersize.py",
		"/E/github/Trusty-cogs/reee/reee.py",
		"/E/github/Trusty-cogs/hockey/menu.py",
		"/E/github/Trusty-cogs/hockey/oilers.py",
		"/E/github/Trusty-cogs/hockey/teams.py",
		"/E/github/Trusty-cogs/hockey/teamentry.py",
		"/E/github/Trusty-cogs/hockey/goal.py",
		"/E/github/Trusty-cogs/hockey/helper.py",
		"/D/dameznet-158219/www/index.html",
		"/E/github/Trusty-cogs/twitch/info.json",
		"/E/github/Trusty-cogs/twitch/errors.py",
		"/E/github/Trusty-cogs/tarot/info.json",
		"/E/github/Trusty-cogs/hue/info.json",
		"/E/github/Trusty-cogs/imagemaker/info.json",
		"/E/github/Trusty-cogs/juche/info.json",
		"/E/github/Trusty-cogs/mock/info.json",
		"/E/github/Trusty-cogs/reee/info.json",
		"/E/github/Trusty-cogs/starboard/info.json",
		"/E/github/yaml_output/hockey.yaml",
		"/E/github/yaml_output/readyplayerone.yaml",
		"/E/github/Trusty-cogs/blizzard/blizzard.py",
		"/E/github/Trusty-cogs/info.json",
		"/E/github/Trusty-cogs/backup/info.json",
		"/E/github/Trusty-cogs/anime/info.json",
		"/E/github/Trusty-cogs/imgflip/info.json",
		"/E/github/Trusty-cogs/convertinfo.py",
		"/E/github/Trusty-cogs/stickyroles/info.json",
		"/E/github/Trusty-cogs/welcome/info.json",
		"/E/github/Trusty-cogs/autorole/info.json",
		"/E/github/Trusty-cogs/cleverbot/info.json",
		"/E/github/Trusty-cogs/twitch/__init__.py",
		"/E/github/Trusty-cogs/trump/trump.py",
		"/E/github/Trusty-cogs/pillconvert/pillconvert.py",
		"/E/github/Trusty-cogs/con",
		"/E/github/Trusty-cogs/weather/info.json",
		"/E/github/Trusty-cogs/tweets/info.json",
		"/E/github/Trusty-cogs/trump/info.json",
		"/E/github/Trusty-cogs/translate/info.json",
		"/E/github/Trusty-cogs/serverwhitelist/info.json",
		"/E/github/Trusty-cogs/runescape/info.json",
		"/E/github/Trusty-cogs/rekt/info.json",
		"/E/github/Trusty-cogs/modlogs/info.json",
		"/E/github/Trusty-cogs/insult/info.json",
		"/E/github/Trusty-cogs/hockey/info.json",
		"/E/github/Trusty-cogs/gab/info.json",
		"/E/github/Trusty-cogs/fun/info.json",
		"/E/github/Trusty-cogs/faces/info.json",
		"/E/github/Trusty-cogs/emojireact/info.json",
		"/E/github/Trusty-cogs/decode/info.json",
		"/E/github/Trusty-cogs/covfefe/info.json",
		"/E/github/Trusty-cogs/conversions/info.json"
	],
	"find":
	{
		"height": 27.0
	},
	"find_in_files":
	{
		"height": 105.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"twitch_follower",
			"twitch_profile",
			"twitch_follower",
			"print",
			"eval",
			"rip",
			"get_team",
			"data.plays",
			"teams",
			"self.teams",
			"teams",
			"scoring_team",
			"teams",
			"bytes_download",
			"run_process",
			"download",
			"isgif",
			"check_func",
			"check",
			"check_func",
			"command_check",
			"self.cursor",
			"check_func",
			"bundled_data_path(self)",
			"this command is for gifs",
			"do_vw",
			"bytes_download",
			"/cogs/notsobot/vw",
			"def r",
			"'avatar'",
			"avatar",
			"aesthetics",
			"bubbles",
			"bubble",
			"protocol",
			"self.bot.run_process(",
			"run_process",
			"self.image_mimes",
			"isimage",
			"await self.bot.edit",
			"await self.bot.edit_message(x, ",
			"await self.bot.edit_message",
			"await self.bot.delete_message(ctx.message)",
			"await self.bot.delete_message(xx)",
			"await self.bot.delete_message(msg)",
			"aiohttp.Timeout(",
			"isimage",
			"str(bundled_data_path(self))(",
			"b1",
			"await file",
			"file = discord.File(",
			"await self.bot.upload(",
			"self.bot.upload(",
			"get_emote_image",
			"get_json",
			"uuid",
			"self.bot.random",
			"random",
			"mention_regex",
			"server",
			"find_member",
			"attachment",
			"attachment[",
			"attachment",
			"[\"url\"]",
			"self.bot.send_message(channel, ",
			"get_attachment_images",
			"em = await self.make_embed(member)",
			"get_welcome_channel",
			"self.escape",
			"get_text",
			"self.cursor",
			"self.download",
			"self.files_path",
			"await await ",
			"on_message",
			"default_team",
			"Context",
			"asyncio",
			"randomize_colour",
			"teams",
			"Tuple",
			"teams",
			"default_team",
			"discord",
			"division",
			"\"\"\n",
			"beemovie",
			"print",
			"functools",
			"new mombasa",
			"Tuple",
			"commands",
			"@twitch",
			"maybe_get_twitch_name",
			"twitch_user.",
			"cmd_name_name",
			"cmd",
			"session",
			"__unload",
			"twitch_menu",
			"hockey_menu",
			"make_gif",
			"sys",
			"cv2",
			"db",
			"check_streams",
			"stream_alerts",
			"initialize",
			"entities",
			"url",
			"media",
			"when the covenant",
			"full",
			"extended_ent",
			"format_patch",
			"format_",
			", pass_context=True",
			"self.impact",
			"giffile",
			"show\":true",
			"bundled_data",
			"np",
			"\t",
			"goals",
			"print(",
			"print"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"TwitchProfile",
			"TwitchFollower",
			"",
			"self.run_process(",
			"await x.edit(",
			"await ctx.message.delete()",
			"await xx.delete()",
			"await msg.delete()",
			"str(bundled_data_path(self)/",
			"file = discord.File(",
			"self.random",
			"guild",
			"channel.send(",
			"channel.send",
			"em = await self.make_embed(member, msg)",
			"str(bundled_data_path(self))",
			"await ",
			"await",
			"@twitchhelp",
			"twitch_profile.",
			"cmd_name",
			"twitch_menu",
			"make_trump_gif",
			"config",
			"",
			"    "
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1075,
						"regions":
						{
						},
						"selection":
						[
							[
								159,
								159
							]
						],
						"settings":
						{
							"__vi_external_disable": true,
							"draw_white_space": "none",
							"git_repo": "E:\\github\\Trusty-cogs",
							"git_status": true,
							"git_view": "status",
							"syntax": "Packages/SublimeGit/syntax/SublimeGit Status.tmLanguage",
							"translate_tabs_to_spaces": false,
							"word_wrap": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "twitch/twitch.py",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 18823,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "hockey/hockey.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56887,
						"regions":
						{
						},
						"selection":
						[
							[
								10318,
								10318
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3836.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "hockey/game.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4402,
						"regions":
						{
						},
						"selection":
						[
							[
								1288,
								1525
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 4,
					"file": "hockey/pickems.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1236,
						"regions":
						{
						},
						"selection":
						[
							[
								741,
								741
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 33.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "starboard/starboard.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15509,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5031.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 42.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.521150592217,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git":
	{
		"height": 127.0
	},
	"output.git-commit":
	{
		"height": 121.0
	},
	"output.git-pull":
	{
		"height": 121.0
	},
	"output.git-push":
	{
		"height": 121.0
	},
	"pinned_build_system": "",
	"project": "trusty-cogs.sublime-project",
	"replace":
	{
		"height": 50.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"E:\\github\\Trusty-cogs\\trusty-cogs.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 196.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
